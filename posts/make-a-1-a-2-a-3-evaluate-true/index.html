<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="7MyzERTGiP"><title>如何让 (a == 1 && a == 2 && a == 3) 返回 true · zhao.zhang</title><meta name="description" content="如何让 (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) 返回 true - loatheb"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://zhangzhao.name/atom.xml" title="zhao.zhang"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">博客</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="https://weibo.com/loatheb" target="_blank" class="nav-list-link">微博</a></li><li class="nav-list-item"><a href="https://github.com/loatheb" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS 订阅</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">如何让 (a == 1 && a == 2 && a == 3) 返回 true</h1><div class="post-info">2018年1月18日</div><div class="post-content"><p>前两天在网上看到了一道很有趣的题目，题目大意为：<strong>JS 环境下，如何让 <code>a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3</code> 这个表达式返回 <code>true</code> ？</strong>。</p>
<p>这道题目乍看之下似乎不太可能，因为在正常情况下，一个变量的值如果没有手动修改，在一个表达式中是不会变化的。当时我也冥思苦想很久，甚至一度怀疑这道题目的答案就是 <strong>不能</strong>。直到在 stackoverflow 上面竟然真的发现了解法 <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/48270127/can-a-1-a-2-a-3-ever-evaluate-to-true">can-a-1-a-2-a-3-ever-evaluate-to-true</a>。</p>
<p>让这个表达式成为 <code>true</code> 的关键就在于这里的宽松相等，JS 在处理宽松相等时会对一些变量进行隐式转换。在这种隐式转换的作用下，真的可以让一个变量在一个表达式中变成不同的值。</p>
<span id="more"></span>
<h2 id="宽松相等下的真值表"><a href="#宽松相等下的真值表" class="headerlink" title="宽松相等下的真值表"></a>宽松相等下的真值表</h2><p>最高票答案给出的解法为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  <span class="attr">i</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">toString</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="property">i</span>++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello World!&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到这个答案，我才恍然大悟，这道题目的考点原来是 JS 获取一个变量所需要做的操作以及其中一些细节。在 JS 中有 <code>===</code> 和 <code>==</code> 两种方式来判断两个变量是否相等。对 JS 稍有了解的人都知道，=== 是严格相等，不仅需要两个变量的值相同，还需要类型也相同，而 == 则是宽松下的相等，只需要值相同就能够判断相等，宽松相等是严格相等的子集。所以在 JS 中，严格相等的两个变量一定也是宽松相等的，但是宽松相等的两个变量，大多数情况下并不是严格相等的。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> === <span class="literal">undefined</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> == <span class="string">&#x27;1&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">1</span> === <span class="string">&#x27;1&#x27;</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>这也就出现了 JS 特有的，变量宽松相等判断的真值表，里面列举了所有在宽松相等比较的情况下，两种变量可能出现的类型：</p>
<p><img src="/images/truth-table.png" alt="/images/truth-table.png"></p>
<p>在上面的表格中，ToNumber(A) 尝试在比较前将参数 A 转换为数字，这与 +A（单目运算符+）的效果相同。ToPrimitive(A) 通过尝试依次调用 A 的 A.toString() 和 A.valueOf() 方法，将参数 A 转换为原始值（Primitive）。</p>
<p>从上图中我们可以看到，当操作数 B 类型为 Number 时，如果希望在宽松相等的情况下整个表达式的结果返回 true，操作数 A 必须满足下面三个条件之一：</p>
<ol>
<li>操作数 A 类型为 String，并且调用 +A 的结果与 B 严格相等</li>
<li>操作数 A 类型为 Boolean，并且调用 +A 的结果与 B 严格相等</li>
<li>操作数 A 类型为 Object，并且调用 toString 或者 ValueOf 返回的结果与 B 严格相等</li>
</ol>
<p>在这里，如果我们要改变 +A 操作的结果相对来说比较困难，因为我们很难在 JS 中去重载 + 操作符的运算。但是在第三种情况下，使 A 的类型为 Object，调用 toString 或 ValueOf 结果与 B 严格相等让我们自己实现就容易的多。</p>
<p>所以上面的答案就是新建了一个对象 <code>a</code> ，并有 <code>toString</code> 方法，当 JS 引擎每次读取 <code>a</code> 的值的时候，发现需要进行宽松判断一个对象和一个数字之间的结果，对于对象就会执行这里的 <code>toString</code> 方法，在这个方法内部，我们每次增加另一个变量的值并返回，就能够在这条表达式中使得 <code>a</code> 的结果有不同的值。</p>
<p>同理，换一种写法，<code>a</code> 为 <code>Object</code> ，使用 <code>valueOf</code> 也是可以完成目标的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cosnt a = &#123;</span><br><span class="line">  <span class="attr">i</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="title function_">valueOf</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">i</span>++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello World!&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="宽松相等下的-Proxy-对象"><a href="#宽松相等下的-Proxy-对象" class="headerlink" title="宽松相等下的 Proxy 对象"></a>宽松相等下的 Proxy 对象</h2><p>有了上面的思路，下面实现起来就容易的多。在 ES6 中 JS 新增了 <code>Proxy</code> 对象，能够对一个对象进行劫持，接受两个参数，第一个是需要被劫持的对象，第二个参数也是一个对象，内部也可以配置每一个元素的 get 方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123; <span class="attr">i</span>: <span class="number">1</span> &#125;, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target</span>) &#123; <span class="keyword">return</span> <span class="function">() =&gt;</span> target.<span class="property">i</span>++ &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello World!&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，Proxy 对象默认的 <code>toString</code> 和 <code>valueOf</code> 方法会返回这个被 getter 劫持过的结果，也能够在宽松相等的条件下满足题意。</p>
<h2 id="严格相等下的实现"><a href="#严格相等下的实现" class="headerlink" title="严格相等下的实现"></a>严格相等下的实现</h2><p>上面的这几种做法，都是利用了宽松相等条件下，JS 里的一些特殊表现来实现的，放在 === 这种严格相等的条件下就不能够满足，因为严格相等的条件下不会对两个操作数做任何处理，直接比较它们值的大小，这样上面的做法就不能成功。</p>
<p>但是这种做法给我们提供了很好的思路，在处理类似的问题的时候，就可以从 JS 获取一个变量执行过程中出发，来进行思考。那么接下来，如果题目中的宽松相等换成了严格相等，这样的例子还存在么？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a === <span class="number">1</span> &amp;&amp; a === <span class="number">2</span> &amp;&amp; a === <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello World!&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答案是显然的，这一次当然不能用 hack 对象或者 Proxy 的 <code>toString</code> 或者 <code>ValueOf</code> 方法来做。从 JS 获取变量的过程入手，理所当然的立马能想到的就是数据的 getter 和 setter 方法，通过这样的 hack ，肯定也能达到题目的严格相等的要求。</p>
<p>在 ES5 之后，<code>Object</code> 新增 <code>defineProperty</code> 方法，它会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回这个对象，对于定义的这个对象有两种描述它的状态，一种称之为数据描述符，一种被称为存取描述符，分别举一个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(a, <span class="string">&#x27;value&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&quot;static&quot;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这四个数据描述服分别作用是 enumerable 判断是否可以枚举，configurable 判断当前属性是否之后再被更改描述符，writable 判断是否可以继续赋值，value 判断这个结果的值。</p>
<p>经过这样的操作之后，a 对象下就有了 value 这个 key ，他被赋予不可继续赋值，不可继续配置，不能被枚举，值为 ‘static’，我们可以通过 a.value 拿到这里的 ‘static’，但是不能继续通过 <code>a.value = &#39;relative&#39;</code> 来继续赋值。</p>
<p>同样的，设置存取描述符也是四个属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">i</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(a, <span class="string">&#x27;value&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> a.<span class="property">i</span> &#125;</span><br><span class="line">  <span class="title function_">set</span>(<span class="params"></span>) &#123; a.<span class="property">i</span>++ &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这里设置时就没有配置 writable 和 value 属性，转而配置了 get 和 set 方法，在这两种配置中，get set 方法和 writable value 是不能共存的，否则就会抛出异常。类似上面这样的设置，当我们访问 a.value 时就会调用 get 方法，当我们通过 <code>a.value = &#39;test&#39;</code> 时，就会执行 set 方法。</p>
<p>所以回归到题目中，当我们访问一个被设置了存取描述符的元素时，如果在 get 方法里面做一些操作，就能巧妙的使得最终的结果达到预期：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="variable language_">window</span>, <span class="string">&#x27;a&#x27;</span>, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> i++ &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a === <span class="number">1</span> &amp;&amp; a === <span class="number">2</span> &amp;&amp; a === <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello World!&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时，这种劫持 getter 和 setter 的方法本质上是执行了一个函数，内部除了用自增变量，还可以有更多的方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> value = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) <span class="keyword">yield</span> i++</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="variable language_">window</span>, <span class="string">&#x27;a&#x27;</span>, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value.<span class="title function_">next</span>().<span class="property">value</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a === <span class="number">1</span> &amp;&amp; a === <span class="number">2</span> &amp;&amp; a === <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello World!&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于严格相等的情况，一般来说只能通过劫持数据的 getter 来进行操作，但是里面具体操作的方法在上面列举的就有很多。</p>
<p>对于宽松相等的情况，除了劫持 getter 以外，因为宽松相等 JS 引擎的缘故，还能用 Object ， Proxy 对象的 valueOf 和 toString 方法达到目的。</p>
<p>当然，在 stackoverflow 中有人提出了另一种做法，在 a 变量的前后用不同的字符达到目的，原理就在于某些字符在肉眼条件下是不可见的，所以虽然看起来都是 a ，但变量实际上的不同的，也能达到题目的要求，不过这就不在本文的讨论范围之内了。</p>
</div></article></div></main><footer><div class="paginator"><a href="/posts/immer-immutable/" class="prev">上一篇</a></div><div id="container"></div><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>var PAGE_SOURCE = 'posts/make-a-1-a-2-a-3-evaluate-true/' || '';</script><script>function pagePathMap(id) {
  var map = {
    'posts/100-lines-of-code-web-module-resolver-1/': '100 行代码实现一个前端 JS 模块打包工具 - 1 - 模块化概览',
    'posts/how-commonjs-load-url-module/': '使 node 也支持从 url 加载一个 module',
    'posts/immer-immutable/': '下一代状态管理工具 immer 简介及源码解析',
    'posts/make-a-1-a-2-a-3-evaluate-true/': '如何让 (a == 1 && a == 2 && a == 3) 返回 true'
  };
  if (map[id]) {
    return map[id];
  }
  return id;
}
var gitment = new Gitment({
  id: pagePathMap(PAGE_SOURCE),
  owner: 'loatheb',
  repo: 'loatheb.github.io',
  oauth: {
      client_id: 'a991a0c92a23969e5050',
      client_secret: '74bc5b7e13c0e3e83cceb75403eefdc4de29a0a8',
  }
})
gitment.render('container')</script><div class="copyright"><p>© 2017 - 2024 <a href="https://zhangzhao.name">loatheb</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-113346354-1",'auto');ga('send','pageview');</script><script>var ba = 'b0c67e473d188544afaabed16e997cf5';
var _hmt = _hmt || [];
(function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?" + ba;
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
})();</script></body></html>