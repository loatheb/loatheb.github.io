<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="sR4b4WnW4b"><title> 100 行代码实现一个前端 JS 模块打包工具 - 1 - 模块化概览 · zhao.zhang</title><meta name="description" content="100 行代码实现一个前端 JS 模块打包工具 - 1 - 模块化概览 - loatheb"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://zhangzhao.name/atom.xml" title="zhao.zhang"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">博客</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="https://weibo.com/loatheb" target="_blank" class="nav-list-link">微博</a></li><li class="nav-list-item"><a href="https://github.com/loatheb" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS 订阅</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">100 行代码实现一个前端 JS 模块打包工具 - 1 - 模块化概览</h1><div class="post-info">2019年11月10日</div><div class="post-content"><p>在 WEB 开发的早期，为了团队协作和代码维护的方便，许多开发者会选择将 JavaScript 代码分开写在不同的文件里面，然后通过多个 script 标签来加载它们。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./a.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./b.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./c.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>虽然每个代码块处在不同的文件中，但最终所有 JS 变量还是会处在同一个 <strong>全局作用域</strong> 下，这时候就需要额外注意由于作用域<code>变量提升</code>所带来的问题。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// a.js</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> num = <span class="number">1</span>;</span></span><br><span class="line"><span class="javascript">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(num), <span class="number">1000</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// b.js</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> num = <span class="number">2</span>;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们分别加载了两个 script 标签，两段 JS 都声明了 <code>num</code> 变量。第一段脚本的本意本来是希望在 1s 后打印自己声明的 <code>num</code> 变量 <strong> 1 </strong>。但最终运行结果却打印了第二段脚本中的 <code>num</code> 变量的结果 <strong> 2 </strong>。虽然两段代码写在不同的文件中，但是因为运行时声明变量都在全局下，最终产生了冲突。</p>
<p>同时，如果代码块之间有依赖关系的话，需要额外关注脚本加载的顺序。如果文件依赖顺序有改动，就需要在 html 手动变更加载标签的顺序，非常麻烦。</p>
<a id="more"></a>
<p>要解决这样的问题，我们就需要将这些脚本文件「模块化」：</p>
<ol>
<li>每个模块都要有自己的 <strong>变量作用域</strong>，两个模块之间的内部变量不会产生冲突。</li>
<li>不同模块之间保留相互 <strong>导入和导出</strong> 的方式方法，模块间能够相互通信。模块的执行与加载遵循一定的规范，能保证彼此之间的依赖关系。</li>
</ol>
<p>主流的编程语言都有处理模块的关键词，在这些语言中，模块与模块之间的内部变量相互不受影响。同时，也可以通过关键字进行模块定义，引入和导出等等，例如 JAVA 里的 <code>module</code> 关键词，python 中的 <code>import</code>。</p>
<p>但是 JavaScript 这门语言在 Ecmascript6 规范之前并没有语言层面的模块导入导出关键词及相关规范。为了解决这样的问题，不同的 JS 运行环境分别有着自己的解决方案。</p>
<h2 id="CommonJS-规范初探"><a href="#CommonJS-规范初探" class="headerlink" title="CommonJS 规范初探"></a>CommonJS 规范初探</h2><p>Node.js 就是一个基于 V8 引擎，事件驱动 I/O 的服务端 JS 运行环境，在 2009 年刚推出时，它就实现了一套名为 <strong>CommonJS</strong> 的模块化规范。</p>
<p>在 CommonJS 规范里，每个 JS 文件就是一个 <strong>模块(module)</strong> ，每个模块内部可以使用 <code>require</code> 函数和 <code>module.exports</code> 对象来对模块进行导入和导出。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个比较简单的 CommonJS 模块</span></span><br><span class="line"><span class="keyword">const</span> moduleA = <span class="built_in">require</span>(<span class="string">"./moduleA"</span>); <span class="comment">// 获取相邻的相对路径 `./moduleA` 文件导出的结果</span></span><br><span class="line"><span class="built_in">module</span>.exports = moduleA;             <span class="comment">// 导出当前模块内部 moduleA 的值</span></span><br></pre></td></tr></table></figure>
<p>下面这三个模块稍微复杂一些，它们都是合法的 CommonJS 模块：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">"./moduleA"</span>);</span><br><span class="line"><span class="keyword">var</span> m = <span class="built_in">require</span>(<span class="string">"./moduleB"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(m);</span><br><span class="line"></span><br><span class="line"><span class="comment">// moduleA.js</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="built_in">require</span>(<span class="string">"./moduleB"</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(m), <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// moduleB.js</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line"><span class="built_in">module</span>.exports = m;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong> index.js </strong> 代表的模块通过执行 <code>require</code> 函数，分别加载了相对路径为 <code>./moduleA</code> 和 <code>./moduleB</code> 的两个模块，同时输出 <strong> moduleB </strong> 模块的结果。</li>
<li><strong> moduleA.js </strong> 文件内也通过 <code>require</code> 函数加载了 <strong> moduleB.js </strong> 模块，在 1s 后也输出了加载进来的结果。</li>
<li><strong> moduleB.js </strong> 文件内部相对来说就简单的多，仅仅定义了一个时间戳，然后直接通过 <code>module.exports</code> 导出。</li>
</ul>
<p>它们之间的 <strong>物理关系</strong> 和 <strong>逻辑关系</strong> 如下图：</p>
<p><img src="/images/100-lines-of-code-web-module-resolver-1/commonjs.png" alt="/100-lines-of-code-web-module-resolver-1/commonjs.png"></p>
<p>在装有 Node.js 的机器上，我们可以直接执行 <code>node index.js</code> 查看输出的结果。我们可以发现，无论执行多少次，最终输出的两行结果均相同。</p>
<p><img src="/images/100-lines-of-code-web-module-resolver-1/commonjs-result.png" alt="/100-lines-of-code-web-module-resolver-1/commonjs-result.png"></p>
<p>虽然这个例子非常简单，但是我们却可以发现 CommonJS 完美的解决了最开始我们提出的痛点：</p>
<ol>
<li>模块之间内部即使有相同的变量名，它们运行时没有冲突。<strong>这说明它有处理模块变量作用域的能力。</strong>上面这个例子中三个模块中均有 <code>m</code> 变量，但是并没有冲突。</li>
<li>moduleB 通过 <code>module.exports</code> 导出了一个内部变量，而它在 moduleA 和 index 模块中能被加载。<strong>这说明它有导入导出模块的方式，同时能够处理基本的依赖关系。</strong></li>
<li>我们在不同的模块加载了 moduleB 两次，我们得到了相同的结果。<strong>这说明它保证了模块单例。</strong></li>
</ol>
<p>但是，这样的 CommonJS 模块只能在 Node.js 环境中才能运行，直接在其他环境中运行这样的代码模块就会报错。这是因为只有 node 才会在解析 JS 的过程中提供一个 <code>require</code> 方法，这样当解析器执行代码时，发现有模块调用了 <code>require</code> 函数，就会通过参数找到对应模块的物理路径，通过系统调用从硬盘读取文件内容，解析这段内容最终拿到导出结果并返回。而其他运行环境并不一定会在解析时提供这么一个 <code>require</code> 方法，也就不能直接运行这样的模块了。</p>
<p>从它的执行过程也能看出来 CommonJS 是一个 <strong>同步加载模块</strong> 的模块化规范，每当一个模块 <code>require</code> 一个子模块时，都会停止当前模块的解析直到子模块读取解析并加载。</p>
<h2 id="适合-WEB-开发的-AMD-模块化规范"><a href="#适合-WEB-开发的-AMD-模块化规范" class="headerlink" title="适合 WEB 开发的 AMD 模块化规范"></a>适合 WEB 开发的 AMD 模块化规范</h2><p>另一个为 WEB 开发者所熟知的 JS 运行环境就是浏览器了。浏览器并没有提供像 Node.js 里一样的 <code>require</code> 方法。不过，受到 CommonJS 模块化规范的启发，WEB 端还是逐渐发展起来了 AMD，SystemJS 规范等适合浏览器端运行的 JS 模块化开发规范。</p>
<p>AMD 全称 <strong>Asynchronous module definition</strong>，意为<code>异步的模块定义</code>，不同于 CommonJS 规范的同步加载，AMD 正如其名所有模块默认都是异步加载，这也是早期为了满足 web 开发的需要，因为如果在 web 端也使用同步加载，那么页面在解析脚本文件的过程中可能使页面暂停响应。</p>
<p>而 AMD 模块的定义与 CommonJS 稍有不同，上面这个例子的三个模块分别改成 AMD 规范就类似这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">'moduleA'</span>, <span class="string">'moduleB'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">moduleA, moduleB</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(moduleB);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// moduleA.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> m = <span class="built_in">require</span>(<span class="string">'moduleB'</span>);</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(m), <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// moduleB.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我们可以对比看到，AMD 规范也支持文件级别的模块，模块 ID 默认为文件名，在这个模块文件中，我们需要使用 <code>define</code> 函数来定义一个模块，在回调函数中接受定义组件内容。这个回调函数接受一个 <code>require</code> 方法，能够在组件内部加载其他模块，这里我们分别传入模块 ID，就能加载对应文件内的 AMD 模块。不同于 CommonJS 的是，这个回调函数的返回值即是模块导出结果。</p>
<p>差异比较大的地方在于我们的入口模块，我们定义好了 moduleA 和 moduleB 之后，入口处需要加载进来它们，于是乎就需要使用 AMD 提供的 <code>require</code> 函数，第一个参数写明入口模块的依赖列表，第二个参数作为回调参数依次会传入前面依赖的导出值，所以这里我们在 index.js 中只需要在回调函数中打印 moduleB 传入的值即可。</p>
<p>Node.js 里我们直接通过 <code>node index.js</code> 来查看模块输出结果，在 WEB 端我们就需要使用一个 html 文件，同时在里面加载这个入口模块。这里我们再加入一个 <strong>index.html</strong> 作为浏览器中的启动入口。</p>
<p>如果想要使用 AMD 规范，我们还需要添加一个符合 AMD 规范的加载器脚本在页面中，符合 AMD 规范实现的库很多，比较有名的就是 <strong>require.js</strong>。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 此处必须加载 require.js 之类的 AMD 模块化库之后才可以继续加载模块--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/require.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 只需要加载入口模块即可 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/index.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用 AMD 规范改造项目之后的关系如下图，在物理关系里多了两个文件，但是模块间的逻辑关系仍与之前相同。</p>
<p><img src="/images/100-lines-of-code-web-module-resolver-1/amd.png" alt="/100-lines-of-code-web-module-resolver-1/amd.png"></p>
<p>启动静态服务之后我们打开浏览器中的控制台，无论我们刷新多少次页面，同 Node.js 的例子一样，输出的结果均相同。同时我们还能看到，虽然我们只加载了 index.js 也就是入口模块，但当使用到 moduleA 和 moduleB 的时候，浏览器就会发请求去获取对应模块的内容。</p>
<p><img src="/images/100-lines-of-code-web-module-resolver-1/amd-console.png" alt="/100-lines-of-code-web-module-resolver-1/amd-console.png"></p>
<p>从结果上来看，AMD 与 CommonJS 一样，都完美的解决了上面说的 <strong>变量作用域</strong> 和 <strong>依赖关系</strong> 之类的问题。但是 AMD 这种默认异步，在回调函数中定义模块内容，相对来说使用起来就会麻烦一些。</p>
<p>同样的，AMD 的模块也不能直接运行在 node 端，因为内部的 <code>define</code> 函数，<code>require</code> 函数都必须配合在浏览器中加载 require.js 这类 AMD 库才能使用。</p>
<h2 id="能同时被-CommonJS-规范和-AMD-规范加载的-UMD-模块"><a href="#能同时被-CommonJS-规范和-AMD-规范加载的-UMD-模块" class="headerlink" title="能同时被 CommonJS 规范和 AMD 规范加载的 UMD 模块"></a>能同时被 CommonJS 规范和 AMD 规范加载的 UMD 模块</h2><p>有时候我们写的模块需要同时运行在浏览器端和 Node.js 里面，这也就需要我们分别写一份 AMD 模块和 CommonJS 模块来运行在各自环境，这样如果每次模块内容有改动还得去两个地方分别进行更改，就比较麻烦。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个返回随机数的模块，浏览器使用的 AMD 模块</span></span><br><span class="line"><span class="comment">// math.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.random();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个返回随机数的模块，Node.js 使用的 CommonJS 模块</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.random();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于这样的问题，<strong> UMD(Universal Module Definition)</strong> 作为一种 <strong>同构(isomorphic)</strong> 的模块化解决方案出现，它能够让我们只需要在一个地方定义模块内容，并同时兼容 AMD 和 CommonJS 语法。</p>
<p>写一个 UMD 模块也非常简单，我们只需要判断一下这些模块化规范的特征值，判断出当前究竟在哪种模块化规范的环境下，然后把模块内容用检测出的模块化规范的语法导出即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">self, factory</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">module</span> === <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">module</span>.exports === <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前环境是 CommonJS 规范环境</span></span><br><span class="line">        <span class="built_in">module</span>.exports = factory();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">'function'</span> &amp;&amp; define.amd) &#123;</span><br><span class="line">        <span class="comment">// 当前环境是 AMD 规范环境</span></span><br><span class="line">        define(factory)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 什么环境都不是，直接挂在全局对象上</span></span><br><span class="line">        self.umdModule = factory();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(<span class="keyword">this</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.random();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<p>上面就是一种定义 UMD 模块的方式，我们可以看到首先他会检测当前加载模块的规范究竟是什么。如果 <code>module.exports</code> 在当前环境中为对象，那么肯定为 CommonJS，我们就能用 <code>module.exports</code> 导出模块内容。如果当前环境中有 <code>define</code> 函数并且 <code>define.amd</code> 为 <code>true</code>，那我们就可以使用 AMD 的 <code>define</code> 函数来定义一个模块。最后，即使没检测出来当前环境的模块化规范，我们也可以直接把模块内容挂载在全局对象上，这样也能加载到模块导出的结果。</p>
<h2 id="ESModule-规范"><a href="#ESModule-规范" class="headerlink" title="ESModule 规范"></a>ESModule 规范</h2><p>前面我们说到的 CommonJS 规范和 AMD 规范有这么几个特点：</p>
<ol>
<li>语言上层的运行环境中实现的模块化规范，模块化规范由环境自己定义。</li>
<li>相互之间不能共用模块。例如不能在 Node.js 运行 AMD 模块，不能直接在浏览器运行 CommonJS 模块。</li>
</ol>
<p>在 EcmaScript 2015 也就是我们常说的 ES6 之后，JS 有了语言层面的模块化导入导出关键词与语法以及与之匹配的 ESModule 规范。使用 ESModule 规范，我们可以通过 <code>import</code> 和 <code>export</code> 两个关键词来对模块进行导入与导出。</p>
<p>还是之前的例子，使用 ESModule 规范和新的关键词就需要这样定义：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./moduleA'</span>;</span><br><span class="line"><span class="keyword">import</span> m <span class="keyword">from</span> <span class="string">'./moduleB'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(m);</span><br><span class="line"></span><br><span class="line"><span class="comment">// moduleA.js</span></span><br><span class="line"><span class="keyword">import</span> m <span class="keyword">from</span> <span class="string">'./moduleB'</span>;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>) =&gt;</span> <span class="built_in">console</span>.log(m), <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// moduleB.js</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> m;</span><br></pre></td></tr></table></figure>
<p>ESModule 与 CommonJS 和 AMD 最大的区别在于，ESModule 是由 JS 解释器实现，而后两者是在宿主环境中运行时实现。ESModule 导入实际上是在语法层面新增了一个语句，而 AMD 和 CommonJS 加载模块实际上是调用了 <code>require</code> 函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个新的语法，我们没办法兼容，如果浏览器无法解析就会报语法错误</span></span><br><span class="line"><span class="keyword">import</span> moduleA <span class="keyword">from</span> <span class="string">"./moduleA"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们只需要新增加一个 require 函数，就可以首先保证 AMD 或 CommonJS 模块不报语法错误</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">require</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> moduleA = <span class="built_in">require</span>(<span class="string">"./moduleA"</span>);</span><br></pre></td></tr></table></figure>
<p>用一张图来表示各种模块规范语法和它们所处环境之间的关系：</p>
<p><img src="/images/100-lines-of-code-web-module-resolver-1/env.png" alt="/100-lines-of-code-web-module-resolver-1/env.png"></p>
<p>每个 JS 的运行环境都有一个解析器，否则这个环境也不会认识 JS 语法。它的作用就是用 ECMAScript 的规范去解释 JS 语法，也就是处理和执行语言本身的内容，例如按照逻辑正确执行 <code>var a = &quot;123&quot;;</code>，<code>function func() {console.log(&quot;hahaha&quot;);}</code> 之类的内容。</p>
<p>在解析器的上层，每个运行环境都会在解释器的基础上封装一些环境相关的 API。例如 Node.js 中的 <code>global</code> 对象、<code>process</code> 对象，浏览器中的 <code>window</code> 对象，<code>document</code> 对象等等。这些运行环境的 API 受到各自规范的影响，例如浏览器端的 W3C 规范，它们规定了 <code>window</code> 对象和 <code>document</code> 对象上的 API 内容，以使得我们能让 <code>document.getElementById</code> 这样的 API 在所有浏览器上运行正常。</p>
<p>ESModule 就属于 JS Core 层面的规范，而 AMD，CommonJS 是运行环境的规范。所以，想要使运行环境支持 ESModule 其实是比较简单的，只需要升级自己环境中的 JS Core 解释引擎到足够的版本，引擎层面就能认识这种语法，从而不认为这是个 <strong>语法错误(syntax error)</strong> ，运行环境中只需要做一些兼容工作即可。</p>
<p>Node.js 在 V12 版本之后才可以使用 ESModule 规范的模块，在 V12 没进入 LTS 之前，我们需要加上 <code>--experimental-modules</code> 的 flag 才能使用这样的特性，也就是通过 <code>node --experimental-modules index.js</code> 来执行。浏览器端 Chrome 61 之后的版本可以开启支持 ESModule 的选项，只需要通过 <code>&lt;script type=&quot;module&quot;&gt;&lt;/script&gt;</code> 这样的标签加载即可。</p>
<p>这也就是说，如果想在 Node.js 环境中使用 ESModule，就需要升级 Node.js 到高版本，这相对来说比较容易，毕竟服务端 Node.js 版本控制在开发人员自己手中。但浏览器端具有分布式的特点，是否能使用这种高版本特性取决于用户访问时的版本，而且这种解释器语法层面的内容无法像 AMD 那样在运行时进行兼容，所以想要直接使用就会比较麻烦。</p>
<h2 id="后模块化时代"><a href="#后模块化时代" class="headerlink" title="后模块化时代"></a>后模块化时代</h2><p>通过前面的分析我们可以看出来，使用 ESModule 的模块明显更符合 JS 开发的历史进程，因为任何一个支持 JS 的环境，随着对应解释器的升级，最终一定会支持 ESModule 的标准。但是，WEB 端受制于用户使用的浏览器版本，我们并不能随心所欲的随时使用 JS 的最新特性。为了能让我们的新代码也运行在用户的老浏览器中，社区涌现出了越来越多的工具，它们能静态将高版本规范的代码编译为低版本规范的代码，最为大家所熟知的就是 <code>babel</code>。</p>
<p>它把 JS Core 中高版本规范的语法，也能按照相同语义在静态阶段转化为低版本规范的语法，这样即使是早期的浏览器，它们内置的 JS 解释器也能看懂。</p>
<p><img src="/images/100-lines-of-code-web-module-resolver-1/babel.png" alt="/100-lines-of-code-web-module-resolver-1/babel.png"></p>
<p>然后，不幸的是，对于模块化相关的 <code>import</code> 和 <code>export</code> 关键字，<code>babel</code> 最终会将它编译为包含 <code>require</code> 和 <code>exports</code> 的 CommonJS 规范。<a href="https://babeljs.io/repl#?babili=false&amp;browsers=&amp;build=&amp;builtIns=false&amp;spec=false&amp;loose=false&amp;code_lz=JYWwDg9gTgLgBAIgHQHoCGA7CMAWBTKAWQgBMBXAGzwQG4AoUSWONOAMyghEVRFMrwBBWnTwAPJvBJ42aSvDQ0gA&amp;debug=false&amp;forceAllTransforms=false&amp;shippedProposals=false&amp;circleciRepo=&amp;evaluate=false&amp;fileSize=false&amp;timeTravel=false&amp;sourceType=module&amp;lineWrap=true&amp;presets=es2015%2Ces2016%2Ces2017%2Cstage-0%2Cstage-1%2Cstage-2%2Cstage-3%2Ces2015-loose&amp;prettier=false&amp;targets=&amp;version=7.7.3&amp;externalPlugins=" target="_blank" rel="noopener">点击连接在线查看编译结果</a></p>
<p><img src="/images/100-lines-of-code-web-module-resolver-1/babel-esmodule.png" alt="/100-lines-of-code-web-module-resolver-1/babel-esmodule.png"></p>
<p>这就造成了另一个问题，这样带有模块化关键词的模块，编译之后还是没办法直接运行在浏览器中，因为浏览器端并不能运行 CommonJS 的模块。为了能在 WEB 端直接使用 CommonJS 规范的模块，除了编译之外，我们还需要一个步骤叫做 <strong>打包(bundle)</strong> 。</p>
<p>打包工具的作用，就是将模块化内部实现的细节抹平，无论是 AMD 还是 CommonJS 模块化规范的模块，经过打包处理之后能变成能直接运行在 WEB 或 Node.js 的内容。</p>
<p>社区有非常多优秀的打包工具，但我写这个系列文章的目的，就是自己实现这么一个简单的能打包模块的工具，跟读者分享一下主要思路和设计。这个小工具的主要目标是要实现：</p>
<ul>
<li>能在 WEB 端使用 CommonJS 模块</li>
<li>能同时支持 <strong>同步加载(synchronous import)</strong> 和 <strong>异步加载(dynamic import)</strong></li>
</ul>
<p>这是 <strong>[100 行代码实现一个前端 JS 模块打包工具]</strong> 这个系列的第一篇文章，主要先阐明模块化的发展、模块化规范的区别以及为什么我们需要打包工具。</p>
<p>下一篇文章开始进入正题，主要介绍打包工具运行时代码相关的思考。</p>
<p>同时本系列介绍的所有代码都开源在自己写的 github 项目<a href="https://github.com/loatheb/100-lines-of-code-challenge-js" target="_blank" rel="noopener">100-lines-of-code-challenge-js</a>当中。</p>
</div></article></div></main><footer><div class="paginator"><a href="/posts/how-commonjs-load-url-module/" class="next">下一篇</a></div><div id="container"></div><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>var PAGE_SOURCE = 'posts/100-lines-of-code-web-module-resolver-1/' || '';</script><script>function pagePathMap(id) {
  var map = {
    'posts/100-lines-of-code-web-module-resolver-1/': '100 行代码实现一个前端 JS 模块打包工具 - 1 - 模块化概览',
    'posts/how-commonjs-load-url-module/': '使 node 也支持从 url 加载一个 module',
    'posts/immer-immutable/': '下一代状态管理工具 immer 简介及源码解析',
    'posts/make-a-1-a-2-a-3-evaluate-true/': '如何让 (a == 1 && a == 2 && a == 3) 返回 true'
  };
  if (map[id]) {
    return map[id];
  }
  return id;
}
var gitment = new Gitment({
  id: pagePathMap(PAGE_SOURCE),
  owner: 'loatheb',
  repo: 'loatheb.github.io',
  oauth: {
      client_id: 'a991a0c92a23969e5050',
      client_secret: '74bc5b7e13c0e3e83cceb75403eefdc4de29a0a8',
  }
})
gitment.render('container')</script><div class="copyright"><p>© 2017 - 2019 <a href="https://zhangzhao.name">loatheb</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-113346354-1",'auto');ga('send','pageview');</script><script>var ba = 'b0c67e473d188544afaabed16e997cf5';
var _hmt = _hmt || [];
(function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?" + ba;
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
})();</script></body></html>