<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zhao.zhang</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhangzhao.name/"/>
  <updated>2019-11-17T03:46:41.583Z</updated>
  <id>https://zhangzhao.name/</id>
  
  <author>
    <name>loatheb</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>100 行代码实现一个前端 JS 模块打包工具 - 1 - 模块化概览</title>
    <link href="https://zhangzhao.name/posts/100-lines-of-code-web-module-resolver-1/"/>
    <id>https://zhangzhao.name/posts/100-lines-of-code-web-module-resolver-1/</id>
    <published>2019-11-09T16:00:00.000Z</published>
    <updated>2019-11-17T03:46:41.583Z</updated>
    
    <content type="html"><![CDATA[<p>在 WEB 开发的早期，为了团队协作和代码维护的方便，许多开发者会选择将 JavaScript 代码分开写在不同的文件里面，然后通过多个 script 标签来加载它们。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./a.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./b.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./c.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>虽然每个代码块处在不同的文件中，但最终所有 JS 变量还是会处在同一个 <strong>全局作用域</strong> 下，这时候就需要额外注意由于作用域<code>变量提升</code>所带来的问题。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// a.js</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> num = <span class="number">1</span>;</span></span><br><span class="line"><span class="javascript">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(num), <span class="number">1000</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// b.js</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> num = <span class="number">2</span>;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这个例子中，我们分别加载了两个 script 标签，两段 JS 都声明了 <code>num</code> 变量。第一段脚本的本意本来是希望在 1s 后打印自己声明的 <code>num</code> 变量 <strong> 1 </strong>。但最终运行结果却打印了第二段脚本中的 <code>num</code> 变量的结果 <strong> 2 </strong>。虽然两段代码写在不同的文件中，但是因为运行时声明变量都在全局下，最终产生了冲突。</p><p>同时，如果代码块之间有依赖关系的话，需要额外关注脚本加载的顺序。如果文件依赖顺序有改动，就需要在 html 手动变更加载标签的顺序，非常麻烦。</p><a id="more"></a><p>要解决这样的问题，我们就需要将这些脚本文件「模块化」：</p><ol><li>每个模块都要有自己的 <strong>变量作用域</strong>，两个模块之间的内部变量不会产生冲突。</li><li>不同模块之间保留相互 <strong>导入和导出</strong> 的方式方法，模块间能够相互通信。模块的执行与加载遵循一定的规范，能保证彼此之间的依赖关系。</li></ol><p>主流的编程语言都有处理模块的关键词，在这些语言中，模块与模块之间的内部变量相互不受影响。同时，也可以通过关键字进行模块定义，引入和导出等等，例如 JAVA 里的 <code>module</code> 关键词，python 中的 <code>import</code>。</p><p>但是 JavaScript 这门语言在 Ecmascript6 规范之前并没有语言层面的模块导入导出关键词及相关规范。为了解决这样的问题，不同的 JS 运行环境分别有着自己的解决方案。</p><h2 id="CommonJS-规范初探"><a href="#CommonJS-规范初探" class="headerlink" title="CommonJS 规范初探"></a>CommonJS 规范初探</h2><p>Node.js 就是一个基于 V8 引擎，事件驱动 I/O 的服务端 JS 运行环境，在 2009 年刚推出时，它就实现了一套名为 <strong>CommonJS</strong> 的模块化规范。</p><p>在 CommonJS 规范里，每个 JS 文件就是一个 <strong>模块(module)</strong> ，每个模块内部可以使用 <code>require</code> 函数和 <code>module.exports</code> 对象来对模块进行导入和导出。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个比较简单的 CommonJS 模块</span></span><br><span class="line"><span class="keyword">const</span> moduleA = <span class="built_in">require</span>(<span class="string">"./moduleA"</span>); <span class="comment">// 获取相邻的相对路径 `./moduleA` 文件导出的结果</span></span><br><span class="line"><span class="built_in">module</span>.exports = moduleA;             <span class="comment">// 导出当前模块内部 moduleA 的值</span></span><br></pre></td></tr></table></figure><p>下面这三个模块稍微复杂一些，它们都是合法的 CommonJS 模块：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">"./moduleA"</span>);</span><br><span class="line"><span class="keyword">var</span> m = <span class="built_in">require</span>(<span class="string">"./moduleB"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(m);</span><br><span class="line"></span><br><span class="line"><span class="comment">// moduleA.js</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="built_in">require</span>(<span class="string">"./moduleB"</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(m), <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// moduleB.js</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line"><span class="built_in">module</span>.exports = m;</span><br></pre></td></tr></table></figure><ul><li><strong> index.js </strong> 代表的模块通过执行 <code>require</code> 函数，分别加载了相对路径为 <code>./moduleA</code> 和 <code>./moduleB</code> 的两个模块，同时输出 <strong> moduleB </strong> 模块的结果。</li><li><strong> moduleA.js </strong> 文件内也通过 <code>require</code> 函数加载了 <strong> moduleB.js </strong> 模块，在 1s 后也输出了加载进来的结果。</li><li><strong> moduleB.js </strong> 文件内部相对来说就简单的多，仅仅定义了一个时间戳，然后直接通过 <code>module.exports</code> 导出。</li></ul><p>它们之间的 <strong>物理关系</strong> 和 <strong>逻辑关系</strong> 如下图：</p><p><img src="/images/100-lines-of-code-web-module-resolver-1/commonjs.png" alt="/100-lines-of-code-web-module-resolver-1/commonjs.png"></p><p>在装有 Node.js 的机器上，我们可以直接执行 <code>node index.js</code> 查看输出的结果。我们可以发现，无论执行多少次，最终输出的两行结果均相同。</p><p><img src="/images/100-lines-of-code-web-module-resolver-1/commonjs-result.png" alt="/100-lines-of-code-web-module-resolver-1/commonjs-result.png"></p><p>虽然这个例子非常简单，但是我们却可以发现 CommonJS 完美的解决了最开始我们提出的痛点：</p><ol><li>模块之间内部即使有相同的变量名，它们运行时没有冲突。<strong>这说明它有处理模块变量作用域的能力。</strong>上面这个例子中三个模块中均有 <code>m</code> 变量，但是并没有冲突。</li><li>moduleB 通过 <code>module.exports</code> 导出了一个内部变量，而它在 moduleA 和 index 模块中能被加载。<strong>这说明它有导入导出模块的方式，同时能够处理基本的依赖关系。</strong></li><li>我们在不同的模块加载了 moduleB 两次，我们得到了相同的结果。<strong>这说明它保证了模块单例。</strong></li></ol><p>但是，这样的 CommonJS 模块只能在 Node.js 环境中才能运行，直接在其他环境中运行这样的代码模块就会报错。这是因为只有 node 才会在解析 JS 的过程中提供一个 <code>require</code> 方法，这样当解析器执行代码时，发现有模块调用了 <code>require</code> 函数，就会通过参数找到对应模块的物理路径，通过系统调用从硬盘读取文件内容，解析这段内容最终拿到导出结果并返回。而其他运行环境并不一定会在解析时提供这么一个 <code>require</code> 方法，也就不能直接运行这样的模块了。</p><p>从它的执行过程也能看出来 CommonJS 是一个 <strong>同步加载模块</strong> 的模块化规范，每当一个模块 <code>require</code> 一个子模块时，都会停止当前模块的解析直到子模块读取解析并加载。</p><h2 id="适合-WEB-开发的-AMD-模块化规范"><a href="#适合-WEB-开发的-AMD-模块化规范" class="headerlink" title="适合 WEB 开发的 AMD 模块化规范"></a>适合 WEB 开发的 AMD 模块化规范</h2><p>另一个为 WEB 开发者所熟知的 JS 运行环境就是浏览器了。浏览器并没有提供像 Node.js 里一样的 <code>require</code> 方法。不过，受到 CommonJS 模块化规范的启发，WEB 端还是逐渐发展起来了 AMD，SystemJS 规范等适合浏览器端运行的 JS 模块化开发规范。</p><p>AMD 全称 <strong>Asynchronous module definition</strong>，意为<code>异步的模块定义</code>，不同于 CommonJS 规范的同步加载，AMD 正如其名所有模块默认都是异步加载，这也是早期为了满足 web 开发的需要，因为如果在 web 端也使用同步加载，那么页面在解析脚本文件的过程中可能使页面暂停响应。</p><p>而 AMD 模块的定义与 CommonJS 稍有不同，上面这个例子的三个模块分别改成 AMD 规范就类似这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">'moduleA'</span>, <span class="string">'moduleB'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">moduleA, moduleB</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(moduleB);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// moduleA.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> m = <span class="built_in">require</span>(<span class="string">'moduleB'</span>);</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(m), <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// moduleB.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们可以对比看到，AMD 规范也支持文件级别的模块，模块 ID 默认为文件名，在这个模块文件中，我们需要使用 <code>define</code> 函数来定义一个模块，在回调函数中接受定义组件内容。这个回调函数接受一个 <code>require</code> 方法，能够在组件内部加载其他模块，这里我们分别传入模块 ID，就能加载对应文件内的 AMD 模块。不同于 CommonJS 的是，这个回调函数的返回值即是模块导出结果。</p><p>差异比较大的地方在于我们的入口模块，我们定义好了 moduleA 和 moduleB 之后，入口处需要加载进来它们，于是乎就需要使用 AMD 提供的 <code>require</code> 函数，第一个参数写明入口模块的依赖列表，第二个参数作为回调参数依次会传入前面依赖的导出值，所以这里我们在 index.js 中只需要在回调函数中打印 moduleB 传入的值即可。</p><p>Node.js 里我们直接通过 <code>node index.js</code> 来查看模块输出结果，在 WEB 端我们就需要使用一个 html 文件，同时在里面加载这个入口模块。这里我们再加入一个 <strong>index.html</strong> 作为浏览器中的启动入口。</p><p>如果想要使用 AMD 规范，我们还需要添加一个符合 AMD 规范的加载器脚本在页面中，符合 AMD 规范实现的库很多，比较有名的就是 <strong>require.js</strong>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 此处必须加载 require.js 之类的 AMD 模块化库之后才可以继续加载模块--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/require.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 只需要加载入口模块即可 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/index.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用 AMD 规范改造项目之后的关系如下图，在物理关系里多了两个文件，但是模块间的逻辑关系仍与之前相同。</p><p><img src="/images/100-lines-of-code-web-module-resolver-1/amd.png" alt="/100-lines-of-code-web-module-resolver-1/amd.png"></p><p>启动静态服务之后我们打开浏览器中的控制台，无论我们刷新多少次页面，同 Node.js 的例子一样，输出的结果均相同。同时我们还能看到，虽然我们只加载了 index.js 也就是入口模块，但当使用到 moduleA 和 moduleB 的时候，浏览器就会发请求去获取对应模块的内容。</p><p><img src="/images/100-lines-of-code-web-module-resolver-1/amd-console.png" alt="/100-lines-of-code-web-module-resolver-1/amd-console.png"></p><p>从结果上来看，AMD 与 CommonJS 一样，都完美的解决了上面说的 <strong>变量作用域</strong> 和 <strong>依赖关系</strong> 之类的问题。但是 AMD 这种默认异步，在回调函数中定义模块内容，相对来说使用起来就会麻烦一些。</p><p>同样的，AMD 的模块也不能直接运行在 node 端，因为内部的 <code>define</code> 函数，<code>require</code> 函数都必须配合在浏览器中加载 require.js 这类 AMD 库才能使用。</p><h2 id="能同时被-CommonJS-规范和-AMD-规范加载的-UMD-模块"><a href="#能同时被-CommonJS-规范和-AMD-规范加载的-UMD-模块" class="headerlink" title="能同时被 CommonJS 规范和 AMD 规范加载的 UMD 模块"></a>能同时被 CommonJS 规范和 AMD 规范加载的 UMD 模块</h2><p>有时候我们写的模块需要同时运行在浏览器端和 Node.js 里面，这也就需要我们分别写一份 AMD 模块和 CommonJS 模块来运行在各自环境，这样如果每次模块内容有改动还得去两个地方分别进行更改，就比较麻烦。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个返回随机数的模块，浏览器使用的 AMD 模块</span></span><br><span class="line"><span class="comment">// math.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.random();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个返回随机数的模块，Node.js 使用的 CommonJS 模块</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.random();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于这样的问题，<strong> UMD(Universal Module Definition)</strong> 作为一种 <strong>同构(isomorphic)</strong> 的模块化解决方案出现，它能够让我们只需要在一个地方定义模块内容，并同时兼容 AMD 和 CommonJS 语法。</p><p>写一个 UMD 模块也非常简单，我们只需要判断一下这些模块化规范的特征值，判断出当前究竟在哪种模块化规范的环境下，然后把模块内容用检测出的模块化规范的语法导出即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">self, factory</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">module</span> === <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">module</span>.exports === <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前环境是 CommonJS 规范环境</span></span><br><span class="line">        <span class="built_in">module</span>.exports = factory();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">'function'</span> &amp;&amp; define.amd) &#123;</span><br><span class="line">        <span class="comment">// 当前环境是 AMD 规范环境</span></span><br><span class="line">        define(factory)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 什么环境都不是，直接挂在全局对象上</span></span><br><span class="line">        self.umdModule = factory();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(<span class="keyword">this</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.random();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>上面就是一种定义 UMD 模块的方式，我们可以看到首先他会检测当前加载模块的规范究竟是什么。如果 <code>module.exports</code> 在当前环境中为对象，那么肯定为 CommonJS，我们就能用 <code>module.exports</code> 导出模块内容。如果当前环境中有 <code>define</code> 函数并且 <code>define.amd</code> 为 <code>true</code>，那我们就可以使用 AMD 的 <code>define</code> 函数来定义一个模块。最后，即使没检测出来当前环境的模块化规范，我们也可以直接把模块内容挂载在全局对象上，这样也能加载到模块导出的结果。</p><h2 id="ESModule-规范"><a href="#ESModule-规范" class="headerlink" title="ESModule 规范"></a>ESModule 规范</h2><p>前面我们说到的 CommonJS 规范和 AMD 规范有这么几个特点：</p><ol><li>语言上层的运行环境中实现的模块化规范，模块化规范由环境自己定义。</li><li>相互之间不能共用模块。例如不能在 Node.js 运行 AMD 模块，不能直接在浏览器运行 CommonJS 模块。</li></ol><p>在 EcmaScript 2015 也就是我们常说的 ES6 之后，JS 有了语言层面的模块化导入导出关键词与语法以及与之匹配的 ESModule 规范。使用 ESModule 规范，我们可以通过 <code>import</code> 和 <code>export</code> 两个关键词来对模块进行导入与导出。</p><p>还是之前的例子，使用 ESModule 规范和新的关键词就需要这样定义：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./moduleA'</span>;</span><br><span class="line"><span class="keyword">import</span> m <span class="keyword">from</span> <span class="string">'./moduleB'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(m);</span><br><span class="line"></span><br><span class="line"><span class="comment">// moduleA.js</span></span><br><span class="line"><span class="keyword">import</span> m <span class="keyword">from</span> <span class="string">'./moduleB'</span>;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>) =&gt;</span> <span class="built_in">console</span>.log(m), <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// moduleB.js</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> m;</span><br></pre></td></tr></table></figure><p>ESModule 与 CommonJS 和 AMD 最大的区别在于，ESModule 是由 JS 解释器实现，而后两者是在宿主环境中运行时实现。ESModule 导入实际上是在语法层面新增了一个语句，而 AMD 和 CommonJS 加载模块实际上是调用了 <code>require</code> 函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个新的语法，我们没办法兼容，如果浏览器无法解析就会报语法错误</span></span><br><span class="line"><span class="keyword">import</span> moduleA <span class="keyword">from</span> <span class="string">"./moduleA"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们只需要新增加一个 require 函数，就可以首先保证 AMD 或 CommonJS 模块不报语法错误</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">require</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> moduleA = <span class="built_in">require</span>(<span class="string">"./moduleA"</span>);</span><br></pre></td></tr></table></figure><p>用一张图来表示各种模块规范语法和它们所处环境之间的关系：</p><p><img src="/images/100-lines-of-code-web-module-resolver-1/env.png" alt="/100-lines-of-code-web-module-resolver-1/env.png"></p><p>每个 JS 的运行环境都有一个解析器，否则这个环境也不会认识 JS 语法。它的作用就是用 ECMAScript 的规范去解释 JS 语法，也就是处理和执行语言本身的内容，例如按照逻辑正确执行 <code>var a = &quot;123&quot;;</code>，<code>function func() {console.log(&quot;hahaha&quot;);}</code> 之类的内容。</p><p>在解析器的上层，每个运行环境都会在解释器的基础上封装一些环境相关的 API。例如 Node.js 中的 <code>global</code> 对象、<code>process</code> 对象，浏览器中的 <code>window</code> 对象，<code>document</code> 对象等等。这些运行环境的 API 受到各自规范的影响，例如浏览器端的 W3C 规范，它们规定了 <code>window</code> 对象和 <code>document</code> 对象上的 API 内容，以使得我们能让 <code>document.getElementById</code> 这样的 API 在所有浏览器上运行正常。</p><p>ESModule 就属于 JS Core 层面的规范，而 AMD，CommonJS 是运行环境的规范。所以，想要使运行环境支持 ESModule 其实是比较简单的，只需要升级自己环境中的 JS Core 解释引擎到足够的版本，引擎层面就能认识这种语法，从而不认为这是个 <strong>语法错误(syntax error)</strong> ，运行环境中只需要做一些兼容工作即可。</p><p>Node.js 在 V12 版本之后才可以使用 ESModule 规范的模块，在 V12 没进入 LTS 之前，我们需要加上 <code>--experimental-modules</code> 的 flag 才能使用这样的特性，也就是通过 <code>node --experimental-modules index.js</code> 来执行。浏览器端 Chrome 61 之后的版本可以开启支持 ESModule 的选项，只需要通过 <code>&lt;script type=&quot;module&quot;&gt;&lt;/script&gt;</code> 这样的标签加载即可。</p><p>这也就是说，如果想在 Node.js 环境中使用 ESModule，就需要升级 Node.js 到高版本，这相对来说比较容易，毕竟服务端 Node.js 版本控制在开发人员自己手中。但浏览器端具有分布式的特点，是否能使用这种高版本特性取决于用户访问时的版本，而且这种解释器语法层面的内容无法像 AMD 那样在运行时进行兼容，所以想要直接使用就会比较麻烦。</p><h2 id="后模块化时代"><a href="#后模块化时代" class="headerlink" title="后模块化时代"></a>后模块化时代</h2><p>通过前面的分析我们可以看出来，使用 ESModule 的模块明显更符合 JS 开发的历史进程，因为任何一个支持 JS 的环境，随着对应解释器的升级，最终一定会支持 ESModule 的标准。但是，WEB 端受制于用户使用的浏览器版本，我们并不能随心所欲的随时使用 JS 的最新特性。为了能让我们的新代码也运行在用户的老浏览器中，社区涌现出了越来越多的工具，它们能静态将高版本规范的代码编译为低版本规范的代码，最为大家所熟知的就是 <code>babel</code>。</p><p>它把 JS Core 中高版本规范的语法，也能按照相同语义在静态阶段转化为低版本规范的语法，这样即使是早期的浏览器，它们内置的 JS 解释器也能看懂。</p><p><img src="/images/100-lines-of-code-web-module-resolver-1/babel.png" alt="/100-lines-of-code-web-module-resolver-1/babel.png"></p><p>然后，不幸的是，对于模块化相关的 <code>import</code> 和 <code>export</code> 关键字，<code>babel</code> 最终会将它编译为包含 <code>require</code> 和 <code>exports</code> 的 CommonJS 规范。<a href="https://babeljs.io/repl#?babili=false&amp;browsers=&amp;build=&amp;builtIns=false&amp;spec=false&amp;loose=false&amp;code_lz=JYWwDg9gTgLgBAIgHQHoCGA7CMAWBTKAWQgBMBXAGzwQG4AoUSWONOAMyghEVRFMrwBBWnTwAPJvBJ42aSvDQ0gA&amp;debug=false&amp;forceAllTransforms=false&amp;shippedProposals=false&amp;circleciRepo=&amp;evaluate=false&amp;fileSize=false&amp;timeTravel=false&amp;sourceType=module&amp;lineWrap=true&amp;presets=es2015%2Ces2016%2Ces2017%2Cstage-0%2Cstage-1%2Cstage-2%2Cstage-3%2Ces2015-loose&amp;prettier=false&amp;targets=&amp;version=7.7.3&amp;externalPlugins=" target="_blank" rel="noopener">点击连接在线查看编译结果</a></p><p><img src="/images/100-lines-of-code-web-module-resolver-1/babel-esmodule.png" alt="/100-lines-of-code-web-module-resolver-1/babel-esmodule.png"></p><p>这就造成了另一个问题，这样带有模块化关键词的模块，编译之后还是没办法直接运行在浏览器中，因为浏览器端并不能运行 CommonJS 的模块。为了能在 WEB 端直接使用 CommonJS 规范的模块，除了编译之外，我们还需要一个步骤叫做 <strong>打包(bundle)</strong> 。</p><p>打包工具的作用，就是将模块化内部实现的细节抹平，无论是 AMD 还是 CommonJS 模块化规范的模块，经过打包处理之后能变成能直接运行在 WEB 或 Node.js 的内容。</p><p>社区有非常多优秀的打包工具，但我写这个系列文章的目的，就是自己实现这么一个简单的能打包模块的工具，跟读者分享一下主要思路和设计。这个小工具的主要目标是要实现：</p><ul><li>能在 WEB 端使用 CommonJS 模块</li><li>能同时支持 <strong>同步加载(synchronous import)</strong> 和 <strong>异步加载(dynamic import)</strong></li></ul><p>这是 <strong>[100 行代码实现一个前端 JS 模块打包工具]</strong> 这个系列的第一篇文章，主要先阐明模块化的发展、模块化规范的区别以及为什么我们需要打包工具。</p><p>下一篇文章开始进入正题，主要介绍打包工具运行时代码相关的思考。</p><p>同时本系列介绍的所有代码都开源在自己写的 github 项目<a href="https://github.com/loatheb/100-lines-of-code-challenge-js" target="_blank" rel="noopener">100-lines-of-code-challenge-js</a>当中。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 WEB 开发的早期，为了团队协作和代码维护的方便，许多开发者会选择将 JavaScript 代码分开写在不同的文件里面，然后通过多个 script 标签来加载它们。&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;src&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;./a.js&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;undefined&quot;&gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;src&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;./b.js&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;undefined&quot;&gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;src&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;./c.js&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;undefined&quot;&gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;虽然每个代码块处在不同的文件中，但最终所有 JS 变量还是会处在同一个 &lt;strong&gt;全局作用域&lt;/strong&gt; 下，这时候就需要额外注意由于作用域&lt;code&gt;变量提升&lt;/code&gt;所带来的问题。&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- index.html --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;undefined&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;javascript&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// a.js&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;javascript&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; num = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;javascript&quot;&gt;    setTimeout(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(num), &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;undefined&quot;&gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;undefined&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;javascript&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// b.js&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;javascript&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; num = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;undefined&quot;&gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在这个例子中，我们分别加载了两个 script 标签，两段 JS 都声明了 &lt;code&gt;num&lt;/code&gt; 变量。第一段脚本的本意本来是希望在 1s 后打印自己声明的 &lt;code&gt;num&lt;/code&gt; 变量 &lt;strong&gt; 1 &lt;/strong&gt;。但最终运行结果却打印了第二段脚本中的 &lt;code&gt;num&lt;/code&gt; 变量的结果 &lt;strong&gt; 2 &lt;/strong&gt;。虽然两段代码写在不同的文件中，但是因为运行时声明变量都在全局下，最终产生了冲突。&lt;/p&gt;
&lt;p&gt;同时，如果代码块之间有依赖关系的话，需要额外关注脚本加载的顺序。如果文件依赖顺序有改动，就需要在 html 手动变更加载标签的顺序，非常麻烦。&lt;/p&gt;
    
    </summary>
    
    
      <category term="CommonJS" scheme="https://zhangzhao.name/tags/CommonJS/"/>
    
      <category term="Node" scheme="https://zhangzhao.name/tags/Node/"/>
    
      <category term="Bundler" scheme="https://zhangzhao.name/tags/Bundler/"/>
    
      <category term="webpack" scheme="https://zhangzhao.name/tags/webpack/"/>
    
      <category term="fis" scheme="https://zhangzhao.name/tags/fis/"/>
    
  </entry>
  
  <entry>
    <title>使 node 也支持从 url 加载一个 module</title>
    <link href="https://zhangzhao.name/posts/how-commonjs-load-url-module/"/>
    <id>https://zhangzhao.name/posts/how-commonjs-load-url-module/</id>
    <published>2018-06-02T16:00:00.000Z</published>
    <updated>2019-11-17T03:46:41.583Z</updated>
    
    <content type="html"><![CDATA[<p>最近两天 ry 的新项目 deno 火了一把。作为 node 项目的发起人，如今基于 go 重新写了一个服务端 JS 上下文（后来又改成了 rust = =），同时项目名 deno 也是 “n”, “o”, “d”, “e” 四个字母更换了一下顺序，引发了大家的强烈关注以及联想。</p><p>与 node 相比，deno 项目在 readme 的一开始就列举出了这个项目的优势和需要解决的问题。里面最让人瞩目的就是所有模块原生支持 ts ，同时也必须从 url 来加载一个模块，这也是与现有的 node.js 里的 CommonJS 模块化最大的不同。</p><a id="more"></a><p>细细品味一下，deno 的模块化与 CommonJS 相比，更多的是一些运行时(runtime)处理的能力。比如运行时处理 ts 的过程，deno 底层的 JS 解释器依旧选择了 V8 引擎，而 V8 引擎并不支持解析 ts，所以 deno 内部也是在获取 ts 文件之后动态转化为 js 文件，而从 url 加载模块就更加动态化。这两点都是目前 node CommonJS 模块所不具备的。</p><p>现有的 CommonJS 底层实现过程也并不是静态化，但是却迟迟没有加入这些特性，需要用一些其他工具才能达到效果。正是因为受到 deno 这些特性的启发，所以我花了一天时间写了个小巧的库，从上层入手使用 CommonJS 来支持从 url 加载模块，同时写下这篇文章也简单介绍一下 CommonJS 的实现细节。</p><h3 id="CommonJS-的执行过程"><a href="#CommonJS-的执行过程" class="headerlink" title="CommonJS 的执行过程"></a>CommonJS 的执行过程</h3><p>想要让 CommonJS 支持 url 访问或者原生加载 ts 模块，必须从 CommonJS 的执行过程中入手，在中间阶段将模块注入进去。而 CommonJS 的执行过程其实总结起来很简单，大概分为以下几点：</p><ul><li>处理路径依赖</li></ul><p>处理路径依赖应该也是所有模块化加载规范的第一步，换言之就是根据路径找到文件的位置。无论是 CommonJS 的 require 还是 ESModule 的 import，无论是相对路径还是绝对路径，都必须首先在内部对这个路径进行处理，找到合适的文件地址。</p><div class="tip"><br>模块路径有可能是绝对路径，有可能是相对路径，有可能省略了后缀(js、node、json)，有可能省略了文件名(index)，甚至是动态路径(运行时基于变量的动态拼接)等等。<br></div><p>首先就是遵守约定，同时按照一定的策略找到这个文件的真实位置，中间的过程就是补齐上面模块化省略的东西。一般都是根据 CommonJS 的这张流程图</p><p><img src="/images/commonjs-module/commonjs.png" alt="commonjs"></p><ul><li>加载文件</li></ul><p>确认了路径并且确保了文件存在之后，加载文件这一步就简单粗暴的多。最简单的方式就是直接读取硬盘上的文件，将纯文本的模块源代码读取至内存。</p><ul><li>拼接函数</li></ul><p>在上一步中获取到的只是代码的文本形式源文件，并不具有执行能力。在接下来的步骤中需要将它变为一个可执行的代码段。</p><div class="tip"><br>如果有同学看过 webpack 打包出来的结果，可以发现有这么一个现象，所有模块化的内容都处在一个函数的闭包中，内部所有的模块加载函数都替换成了 <code>__webpack_require__</code> 这类的 webpack 内部变量。<br></div><p>还有一个问题，在 CommonJS 模块化规范中我们或多或少在每个文件中会写 module, require 等等这样的「字眼」，module 和 require 并不能称为关键字，JS 中关于模块加载方面的关键字只有 ESModule 中 import 和 export 等等相关的内容。在日常的模块书写过程中，module 对象和 require 函数完全是 node 在包解析时注入进去的（类似上面的 <code>__webpack_require__</code>）</p><p>这也就给了我们极大的想象空间，我们也完全可以将上面拿到的 module 进行包裹然后注入我们传递的每一个变量。简单的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 纯文本代码 无法执行</span><br><span class="line">var str = 1;</span><br><span class="line">console.log(str);</span><br></pre></td></tr></table></figure><p>将函数进行拼接，结果依旧是一个纯文本代码。但是已经可以给这个文件内部注入 require module 等变量，只需后续将它变为可执行文件并执行，就能把模块取出来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">require, module, exports, __dirname, __filename</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 纯文本代码</span></span><br><span class="line">  <span class="keyword">var</span> str = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>转化为可执行代码</li></ul><p>拼接完成之后我们拿到的是还是纯字符串的代码，接下来就需要将这个字符串变成真正的代码，也就是将字符串变为可执行代码片段，这种操作在 JS 的历史上一直是危险的代名词…一直以来也有多种方法可以使用，<code>eval</code>、<code>new Function(str)</code> 等等。而在 node 环境中可以直接使用原生提供的 vm 模块，内部的沙盒环境支持我们手动注入一些变量，相对来说安全性还有所保证。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> txt = <span class="string">"function(require, module, exports, __dirname, __filename) &#123;</span></span><br><span class="line"><span class="string">  module.exports = 1;</span></span><br><span class="line"><span class="string">&#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vm = <span class="built_in">require</span>(<span class="string">'vm'</span>);</span><br><span class="line"><span class="keyword">var</span> script = <span class="keyword">new</span> vm.Script(txt);</span><br><span class="line"><span class="keyword">var</span> func = script.runInThisContext();</span><br></pre></td></tr></table></figure><p>上面这个示例中，<code>func</code> 就已经是经过 <code>vm</code> 从字符串变为可执行代码段的结果，我们的 txt 给定的是一个函数，所以此时我们需要调用这个函数来最后完成模块的导出。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = &#123;</span><br><span class="line">  exports: &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">func(<span class="literal">null</span>, m, m.exports);</span><br></pre></td></tr></table></figure><p>这样的话，内部导出的内容就会被外面全局对象 <code>m</code> 所截获，将每一个模块导出的结果缓存到全局的 <code>m</code> 对象上面来。</p><p>而对于 require 函数来讲，注入时我们需要考虑的就是走完上面的几个步骤，require 接受一个字符串变量路径，然后依次通过路径找到文件，获取文件，拼接函数，变为可执行代码段并执行，之后仍给全局的缓存对象，这就是 「require」需要做的内容。</p><h3 id="过程中的切面"><a href="#过程中的切面" class="headerlink" title="过程中的切面"></a>过程中的切面</h3><ul><li>最终形态是什么</li></ul><p>对于最终的形态，本质上我们是要提供一个 require 函数，它的目标就是在 runtime 能够从远端 url 加载 js 模块，能够加载 ts 模块甚至类似 babel 提供 preset 加载各种各样的模块。</p><p>但是我们的 require 无法注入到 node bootstrap 阶段，所以最终结果一定得是 bootsrap 文件使用 CommonJS 模块加载，通过我们自定义的 require 加载的所有文件都能实现功能。</p><ul><li>生命周期的设计</li></ul><p>就如上面的第二部分介绍的那样，对于 require 函数我们要依次做这些事情，完全可以把每个阶段看做一个切面，任何一个阶段只关注输入和输出而不关注上个阶段是如何产出的。</p><p>经过仔细的思考，最终设置了两个核心的过程，<strong>包裹模块内容</strong> 和 <strong>编译文件结果</strong>。</p><p>包裹模块内容就是将字符串的文件结果包裹一下函数，专注于处理字符串结果，将普通文件的文本进行包裹。</p><p>编译文件结果这一步就是将代码结果编译成 node 能够直接识别的 js 而使得下一步沙盒环境进行执行，每次通过文件结果动态在内存进行编译，从而使得下一步 js 的执行。</p><ul><li>同步还是异步？</li></ul><p>这个问题其实困扰了很久。最大的问题就是里面涉及了部分异步加载的问题，按照传统前端的做法，这里一般都是使用 callback 或者 promise（async／await) 的方式，但这样就会带来一个很大的问题。</p><p>如果是 callback 的方式，那么意味着最终我的 require 可能得这样调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="built_in">require</span>(<span class="string">"nedo"</span>);</span><br><span class="line"><span class="keyword">var</span> moduleA = r(<span class="string">"./moduleA"</span>);</span><br><span class="line"><span class="keyword">var</span> moduleB = r(<span class="string">"./moduleB"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">module</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 所有执行过程作为 callback</span></span><br><span class="line">  <span class="comment">// 这里拿到 module 的结果</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">module</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">moduleA(log); <span class="comment">// 传入 callback，moduleA 加载结束执行回调</span></span><br><span class="line">moduleB(log); <span class="comment">// 传入 callback，moduleB 加载结束执行回调</span></span><br></pre></td></tr></table></figure><p>这样就显得很愚蠢，即使改成 AMD 那样的 callback 调用也感觉是在开历史的倒车。</p><p>如果是 promise（async/await) 这样的异步方式，那么意味着最终我的 require 可能得这样调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="built_in">require</span>(<span class="string">"nedo"</span>);</span><br><span class="line"><span class="keyword">var</span> moduleA = r(<span class="string">"./moduleA"</span>);</span><br><span class="line"></span><br><span class="line">moduleA.then(<span class="function"><span class="params">module</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 这里拿到 module 结果</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> moduleB = <span class="keyword">await</span> r(<span class="string">"./moduleB"</span>);</span><br><span class="line">  <span class="comment">// 这里拿到 module 的结果</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>说实话这种方式也显得很愚蠢。不过中间我想了个方法，包裹函数时多包一层，包一个 IIFE 然后自执行一个 async 的 wrapper，不过这样的话 bootstrap 文件就必须还得手动包裹在 async 的函数中，子函数的问题解决了但是上层没有解决，不够完美。</p><p>其实后来仔细的思考了一下，造成这样的问题的原因究其根本是因为 request 是 async 的，这就导致了后续的代码必须以 async 的方式出现。如果我们想要从硬盘读取一个文件，那么我们可以使用 promise 包裹的 fs.readFile，当然我们也可以使用 fs.readFileSync 。前者的方法会让后续的所有调用都变成异步，而后者的代码还是同步，虽然性能很差但是完全符合直觉。</p><p>所以就必须找到一个 sync 的 request 的形式，才能让最终调用变的完美，最终的想法结果应该如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="built_in">require</span>(<span class="string">"nedo"</span>);</span><br><span class="line"><span class="keyword">var</span> moduleA = r(<span class="string">"./moduleA"</span>);</span><br><span class="line"><span class="comment">// moduleA 结果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> moduleB = r(<span class="string">"https://baidu.com"</span>);</span><br><span class="line"><span class="comment">// moduleB 结果，同步阻塞</span></span><br></pre></td></tr></table></figure><p>思考了半天不知道 sync 的 request 应该怎么写，后来只得求助万能的 npmjs，结果真的发现了一个 <code>sync-request</code> 的包，仔细研究了一下代码发现核心是借助了 <code>sync-rpc</code> 这个包，虽然这个包 github 只有 5 个 star，下载量也不大。但是感觉却是非常的厉害，能够将任何异步的代码转化为同步调用的形式，战略性 star，日后可能大有所为…</p><p><img src="/images/commonjs-module/sync-rpc.png" alt="sync-rpc"></p><ul><li>runtime 编译</li></ul><p>解决了 request async 的问题之后其他问题都变的非常简单，ts 使用 babel + ts preset 在内存中完成了编译，如果想要增加任何文件的支持，只需要在 lib/compile 下加入对应的文件后缀即可，在内存中只要能够完成编译就能够最终保证代码结果。</p><ul><li>top level await</li></ul><p>在之前的过程中我们只是包了一层注入参数的函数进去，当然也可以上层包裹一层 async 函数，这样就可以在使用 nedo require 的包内部直接使用顶层 await，不需要再使用 async 进行包裹</p><h3 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h3><p>最后经过几个小时的不懈努力，最终能够将 hello world 跑起来了，代码还处于 pre-pre-pre-prototype 的阶段。仓库地址 <a href="https://github.com/loatheb/nedo" target="_blank" rel="noopener">nedo</a> ，希望大家多帮忙 review，提供更多建设性的意见…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近两天 ry 的新项目 deno 火了一把。作为 node 项目的发起人，如今基于 go 重新写了一个服务端 JS 上下文（后来又改成了 rust = =），同时项目名 deno 也是 “n”, “o”, “d”, “e” 四个字母更换了一下顺序，引发了大家的强烈关注以及联想。&lt;/p&gt;
&lt;p&gt;与 node 相比，deno 项目在 readme 的一开始就列举出了这个项目的优势和需要解决的问题。里面最让人瞩目的就是所有模块原生支持 ts ，同时也必须从 url 来加载一个模块，这也是与现有的 node.js 里的 CommonJS 模块化最大的不同。&lt;/p&gt;
    
    </summary>
    
    
      <category term="CommonJS" scheme="https://zhangzhao.name/tags/CommonJS/"/>
    
      <category term="Node" scheme="https://zhangzhao.name/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>immer.js 简介及源码简析：更简单，更快速的创建不可变数据类型</title>
    <link href="https://zhangzhao.name/posts/immer-immutable/"/>
    <id>https://zhangzhao.name/posts/immer-immutable/</id>
    <published>2018-01-31T16:00:00.000Z</published>
    <updated>2019-11-17T03:46:41.583Z</updated>
    
    <content type="html"><![CDATA[<p>JS 里面的变量类型可以大致分为基本类型和引用类型。在使用过程中，引用类型经常会产生一些无法意识到的副作用，所以在现代 JS 开发过程中，有经验的开发者都会在特定位置有意识的写下断开引用的不可变数据类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引用带来的副作用</span></span><br><span class="line"><span class="keyword">var</span> a = [&#123; <span class="attr">val</span>: <span class="number">1</span> &#125;]</span><br><span class="line"><span class="keyword">var</span> b = a.map(<span class="function"><span class="params">item</span> =&gt;</span> item.val = <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 期望：b 的每一个元素的 val 值变为 2</span></span><br><span class="line"><span class="built_in">console</span>.log(a[<span class="number">0</span>].val) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><a id="more"></a><div class="tip"><br>  从上述例子我们可以发现，本意是只想让 <code>b</code> 中的每一个元素的值变为 2 ，但却无意中改掉了 <code>a</code> 中每一个元素的结果，这是不符合预期的。接下来如果某个地方使用到了 <code>a</code> ，很容易发生一些我们难以预料并且难以 debug 的 bug。<br></div><p>在发现这样的问题之后，解决方案也很简单。一般来说当需要传递一个引用类型的变量（例如对象）进一个函数时，我们可以使用 <code>Object.assign</code> 或者 <code>...</code> 对对象进行解构，成功断掉一层的引用。</p><p>例如上面的问题我们可以改用下面的这种写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [&#123; <span class="attr">val</span>: <span class="number">1</span> &#125;]</span><br><span class="line"><span class="keyword">var</span> b = a.map(<span class="function"><span class="params">item</span> =&gt;</span> (&#123; ...item, <span class="attr">val</span>: <span class="number">2</span> &#125;))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a[<span class="number">0</span>].val) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b[<span class="number">0</span>].val) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>但是这样做会有另外一个问题，无论是 <code>Object.assign</code> 还是 <code>...</code> 的解构操作，断掉的引用也只是一层，如果对象嵌套超过一层，这样做还是有一定的风险。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 深层次的对象嵌套</span></span><br><span class="line"><span class="keyword">var</span> a = [&#123;</span><br><span class="line">    val: <span class="number">1</span>,</span><br><span class="line">    desc: &#123; <span class="attr">text</span>: <span class="string">'a'</span> &#125;</span><br><span class="line">  &#125;]</span><br><span class="line"><span class="keyword">var</span> b = a.map(<span class="function"><span class="params">item</span> =&gt;</span> (&#123; ...item, <span class="attr">val</span>: <span class="number">2</span> &#125;))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a === b)           <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(a.desc === b.desc) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>a.desc === b.desc</code> 表达式的结果仍为 true，这说明在程序内部 <code>a.desc</code> 和 <code>b.desc</code> 仍然指向相同的引用。如果后面的代码一不小心在一个函数内部直接通过 <code>b.desc</code> 进行赋值，就一定会改变具有相同引用的 <code>a.desc</code> 部分的结果，这当然是不符合我们的预期的。</p><p>所以在这之后，大多数情况下我们会考虑 <strong>深拷贝</strong> 这样的操作来完全避免上面遇到的所有问题。<strong>深拷贝</strong>，顾名思义就是在遍历过程中，如果遇到了可能出现引用的数据类型（大多数情况下是 Object），就会递归的完全创建一个新的类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个简单的深拷贝函数，去掉了一些胶水部分</span></span><br><span class="line"><span class="comment">// 用户态输入一定是一个 Plain Object，并且所有 value 也是 Plain Object</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj)</span><br><span class="line">  <span class="keyword">return</span> keys.reduce(<span class="function">(<span class="params">memo, current</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> value = obj[current]</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">'object'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...memo,</span><br><span class="line">        [current]: deepClone(value),</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      ...memo,</span><br><span class="line">      [current]: value,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, &#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用上面的 deepClone 函数进行简单测试</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  val: <span class="number">1</span>,</span><br><span class="line">  desc: &#123;</span><br><span class="line">    text: <span class="string">'a'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = deepClone(a)</span><br><span class="line"></span><br><span class="line">b.val = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(a.val) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b.val) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">b.desc.text = <span class="string">'b'</span></span><br><span class="line"><span class="built_in">console</span>.log(a.desc.text) <span class="comment">// 'a'</span></span><br><span class="line"><span class="built_in">console</span>.log(b.desc.text) <span class="comment">// 'b'</span></span><br></pre></td></tr></table></figure><p>上面的这个 <code>deepClone</code> 可以满足简单的需求，但是真正在生产工作中，我们需要考虑非常多的因素。举例来说：</p><ul><li>key 里面 getter，setter 以及原型链上的内容如何处理？</li><li>value 是一个 Symbol 如何处理？</li><li>value 是其他非 Plain Object 如何处理？</li><li>value 内部出现了一些循环引用如何处理？</li></ul><p>因为有太多不确定因素，所以在真正的工程实践中，还是推荐大家使用大型开源项目里面的工具函数。比较常用的为大家所熟知的就是 <code>lodash.cloneDeep</code>，无论是安全性还是效果都有所保障。</p><p>其实，这种去除引用数据类型副作用的数据的概念我们称作 immutable ，意为不可变的数据，其实理解为不可变关系更为恰当。每当我们创建一个被 <code>deepClone</code> 过的数据，新的数据进行有<strong>副作用</strong> (side effect) 的操作都不会影响到之前的数据，这也就是 immutable 的精髓和本质。</p><div class="tip"><br>  这里的<strong>副作用</strong>不只局限于通过「点」操作对属性赋值。例如 array 里面的 push,pop,splice 等操作都是会改变原来的数据，这些操作都算是非 immutable。<br></div><p>然而 deepClone 这种函数虽然断绝了引用关系实现了 immutable，但是相对来说开销太大（因为无论下层的数据是否改动，都需要重新创建）。所以在 2014 年，facebook 的 immutable-js 横空出世，即保证了数据间的 immutable ，又兼顾了性能。</p><h2 id="immutable-js-简介"><a href="#immutable-js-简介" class="headerlink" title="immutable-js 简介"></a>immutable-js 简介</h2><p>immutable-js 使用了另一套数据结构的 API ，与我们的常见操作有些许不同，它将所有的原生数据类型（Object， Array等）都会转化成 immutable-js 的内部对象（Map，List 等），并且任何操作最终都会返回一个新的 immutable 的值。</p><p>上面的例子使用 immutable-js 就需要这样改造一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; fromJS &#125; = <span class="built_in">require</span>(<span class="string">'immutable'</span>)</span><br><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  val: <span class="number">1</span>,</span><br><span class="line">  desc: &#123;</span><br><span class="line">    text: <span class="string">'a'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = fromJS(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = a.set(<span class="string">'val'</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a.get(<span class="string">'val'</span>)) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b.get(<span class="string">'val'</span>)) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pathToText = [<span class="string">'desc'</span>, <span class="string">'text'</span>]</span><br><span class="line"><span class="keyword">const</span> c = a.setIn([...pathToText], <span class="string">'c'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a.getIn([...pathToText])) <span class="comment">// 'a'</span></span><br><span class="line"><span class="built_in">console</span>.log(c.getIn([...pathToText])) <span class="comment">// 'c'</span></span><br></pre></td></tr></table></figure><p>对于性能方面，immutable-js 也有它的优势，举个简单的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; fromJS &#125; = <span class="built_in">require</span>(<span class="string">'immutable'</span>)</span><br><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  content: &#123;</span><br><span class="line">    time: <span class="string">'2018-02-01'</span>,</span><br><span class="line">    val: <span class="string">'Hello World'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  desc: &#123;</span><br><span class="line">    text: <span class="string">'a'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = fromJS(data)</span><br><span class="line"><span class="keyword">const</span> b = a.setIn([<span class="string">'desc'</span>, <span class="string">'text'</span>], <span class="string">'b'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(b.get(<span class="string">'desc'</span>) === a.get(<span class="string">'desc'</span>))       <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(b.get(<span class="string">'content'</span>) === a.get(<span class="string">'content'</span>)) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = a.toJS()</span><br><span class="line"><span class="keyword">const</span> d = b.toJS()</span><br><span class="line"><span class="built_in">console</span>.log(c.desc === d.desc)       <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(c.content === d.content) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>从上面的例子可以看出来，在 immutable-js 的数据结构中，深层次的对象在没有修改的情况下仍然能够保证严格相等，这也是 immutable-js 的另一个特点 「深层嵌套对象的结构共享」。即嵌套对象在没有改动前仍然在内部保持着之前的引用，修改后断开引用，但是却不会影响之前的结果。</p><p>经常使用 React 的同学肯定也对 immutable-js 不陌生，这也就是为什么 immutable-js 会极大提高 React 页面性能的原因之一了。</p><p>当然能够达到 immutable 效果的当然不只这几个个例，这篇文章我主要想介绍实现 immutable 的库其实是 immer。</p><h2 id="immer-简介"><a href="#immer-简介" class="headerlink" title="immer 简介"></a>immer 简介</h2><p>immer 的作者同时也是 mobx 的作者，一个看起来非常感性的中年大叔。mobx 又像是把 Vue 的一套东西融合进了 React，已经在社区取得了不错的反响。immer 则是他在 immutable 方面所做的另一个实践，在 2018-02-01，immer 成功发布了 <strong>1.0.0</strong> 版本，我差不多在一个月前开始关注这个项目，所以大清早看到作者在 twitter 上发的通告，有感而发今天写下这篇文章，算是简单介绍一下 immer 这个 immutable 框架的使用以及内部简单的实现原理。</p><p>与 immutable-js 最大的不同，immer 是使用原生数据结构的 API 而不是内置的 API，举个简单例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> produce = <span class="built_in">require</span>(<span class="string">'immer'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">  done: <span class="literal">false</span>,</span><br><span class="line">  val: <span class="string">'string'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newState = produce(state, (draft) =&gt; &#123;</span><br><span class="line">  draft.done = <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(state.done)    <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(newState.done) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>所有<strong>具有副作用的逻辑</strong>都可以放进 produce 的第二个参数的函数内部进行处理。在这个函数内部对原来的数据进行任何操作，都不会对原对象产生任何影响。</p><p>简单介绍完使用之后，下面就开始简单介绍它的内部实现。</p><div class="tip"><br>  不过在这之前，想先通过上面的例子简单的思考一下。<br><br>  通过文章最开始的例子我们就能明白，给函数传入一个对象，直接通过「点」操作符对对象内部的一个属性进行更改是一定会改变外面的结果的。而上面的这个例子中，<code>draft</code> 参数传入进去，与 <code>state</code> 一样也有 done 这个属性，但是在通过 <code>draft.done</code> 改变值之后，原来的 <code>state.done</code> 并没有发生改变。<br><br>  其实到这里，结合之前研究 vue 源码的经验，大概就能笃定，这里一定用了 <code>Object.defineProperty</code>，对数据的结果做了一部分劫持，从而做了一些新的操作完成目的。<br></div><h2 id="immer-原理解析"><a href="#immer-原理解析" class="headerlink" title="immer 原理解析"></a>immer 原理解析</h2><p>真正翻开源码，诚然里面确实有 defineProperty 的身影，不过在另一个核心的文件中，用了一种新的方式，那就是 ES6 中新增的 Proxy 对象。Proxy 对象允许拦截某些操作并实现自定义行为，但大多数 JS 程序员可能并不经常使用这种元编程模式，所以这里简单且快速的介绍一下它的使用。</p><p>Proxy 对象接受两个参数，第一个参数是需要操作的对象，第二个参数是设置对应拦截的属性，这里的属性同样也支持 get，set 等等，也就是劫持了对应元素的读和写，能够在其中进行一些操作，最终返回一个 Proxy 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  get(target, key) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'proxy get key'</span>, key)</span><br><span class="line">  &#125;,</span><br><span class="line">  set(target, key, value) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'value'</span>, value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">proxy.info     <span class="comment">// 'proxy get key info'</span></span><br><span class="line">proxy.info = <span class="number">1</span> <span class="comment">// 'value 1'</span></span><br></pre></td></tr></table></figure><p>上面这个例子中传入的第一个参数是一个空对象，当然我们可以用其他已有内容的对象代替它。</p><p>immer 的做法就是维护一份 state 在内部，劫持所有操作，内部来判断是否有变化从而最终决定如何返回。下面这个例子就是一个构造函数，如果将它的实例传入 Proxy 对象作为第一个参数，就能够后面的处理对象中使用其中的方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(state) &#123;</span><br><span class="line">    <span class="keyword">this</span>.modified = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">this</span>.source = state</span><br><span class="line">    <span class="keyword">this</span>.copy = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  get(key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.modified) <span class="keyword">return</span> <span class="keyword">this</span>.source[key]</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.copy[key]</span><br><span class="line">  &#125;</span><br><span class="line">  set(key, value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.modified) <span class="keyword">this</span>.modifing()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.copy[key] = value</span><br><span class="line">  &#125;</span><br><span class="line">  modifing() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.modified) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">this</span>.modified = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">this</span>.copy = <span class="built_in">Array</span>.isArray(<span class="keyword">this</span>.source)</span><br><span class="line">      ? <span class="keyword">this</span>.source.slice()</span><br><span class="line">      : &#123; ...this.source &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个 Store 构造函数相比源代码省略了很多判断的部分。实例上面有 <code>modified</code>，<code>source</code>，<code>copy</code> 三个属性，有 <code>get</code>，<code>set</code>，<code>modifing</code> 三个方法。<code>modified</code> 作为内置的 flag，判断如何进行设置和返回。</p><p>里面最关键的就应该是 <code>modifing</code> 这个函数，如果触发了 setter 并且之前没有改动过的话，就会手动将 <code>modified</code> 这个 flag 设置为 <code>true</code>，并且手动通过原生的 API 实现一层 immutable。</p><p>对于 Proxy 的第二个参数，在简版的实现中，我们只是简单做一层转发，任何对元素的读取和写入都转发到 store 实例内部方法去处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PROXY_FLAG = <span class="string">'@@SYMBOL_PROXY_FLAG'</span></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  get(target, key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key === PROXY_FLAG) <span class="keyword">return</span> target</span><br><span class="line">    <span class="keyword">return</span> target.get(key)</span><br><span class="line">  &#125;,</span><br><span class="line">  set(target, key, value) &#123;</span><br><span class="line">    <span class="keyword">return</span> target.set(key, value)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="tip">这里在 getter 里面加一个 flag 的目的就在于将来从 proxy 对象中获取 store 实例更加方便。</div><p>最终我们能够完成这个 produce 函数，创建 store 实例后创建 proxy 实例。然后将创建的 proxy 实例传入第二个函数中去。这样无论在内部做怎样有副作用的事情，最终都会在 store 实例内部将它解决。最终得到了修改之后的 proxy 对象，而 proxy 对象内部已经维护了两份 state ，通过判断 modified 的值来确定究竟返回哪一份。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">produce</span>(<span class="params">state, producer</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> store = <span class="keyword">new</span> Store(state)</span><br><span class="line">  <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(store, handler)</span><br><span class="line"></span><br><span class="line">  producer(proxy)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> newState = proxy[PROXY_FLAG]</span><br><span class="line">  <span class="keyword">if</span> (newState.modified) <span class="keyword">return</span> newState.copy</span><br><span class="line">  <span class="keyword">return</span> newState.source</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，一个分割成 Store 构造函数，handler 处理对象和 produce 处理 state 这三个模块的最简版就完成了，将它们组合起来就是一个最最最 tiny 版的 immer ，里面去除了很多不必要的校验和冗余的变量。但真正的 immer 内部也有其他的功能，例如上面提到的<strong>深层嵌套对象的结构化共享</strong>等等。</p><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>性能方面，就用 immer 官方 README 里面的介绍来说明情况。</p><p>这是一个关于 immer 性能的简单测试。这个测试使用了 100000 个组件元素，并且更新其中的 10000 个。freeze 表示状态树在生成之后已被冻结。这是一个最佳的开发实践，因为它可以防止开发人员意外修改状态树。</p><p><img src="/images/immer/performance.png" alt="performance"></p><p>通过上图的观察，基本可以得出：</p><ul><li><p>从 immer 的角度来看，这个性能环境比其他框架和库要恶劣的多，因为它必须代理的根节点相对于其余的数据集来说大得多</p></li><li><p>从 mutate 和 deepclone 来看，mutate 基准确定了数据更改费用的基线，没有不可变性（或深度克隆情况下的结构共享）</p></li><li><p>使用 Proxy 的 immer 大概是手写 reducer 的两倍，当然这在实践中可以忽略不计</p></li><li><p>immer 大致和 immutable-js 一样快。但是，immutable-js 最后经常需要 toJS 操作，这里的性能的开销是很大的。例如将不可变的 JS 对象转换回普通的对象，将它们传递给组件中，或着通过网络传输等等（还有将从例如服务器接收到的数据转换为 immutable-js 内置对象的前期成本）</p></li><li><p>immer 的 ES5 实现速度明显较慢。对于大多数的 reducer 来说，这并不重要，因为处理大量数据的 reducer 可以完全不（或者仅部分）使用 immer 的 produce 函数。幸运的是，immer 完全支持这种选择性加入的情况</p></li><li><p>在 freeze 的版本中，只有 mutate，deepclone 和原生 reducer 才能够递归地冻结全状态树，而其他测试用例只冻结树的修改部分</p></li></ul><h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>其实纵观 immer 的实现，核心的原理就是放在了对对象读写的劫持，从表现形式上立刻就能让人想到 vue ，mobx 从核心原理上来说也是对对象的读写劫持，最近有另一篇非常火的文章 – 如何让 <code>(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3)</code> 为 true，也相信不少的小伙伴读过，除了那个肉眼不可见字符的答案，其他答案也算是对对象的读写劫持从而达到目标。</p><p>所以说在 JS 中，很多知识相辅相成，理论上有多少种方式能让 (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) 为 true，理论上就会有多少种 MVVM 的组成方式，甚至就有多少种方法能够实现这样的 immutable。所以每一个小小的知识点，未来都可能影响前端的发展。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JS 里面的变量类型可以大致分为基本类型和引用类型。在使用过程中，引用类型经常会产生一些无法意识到的副作用，所以在现代 JS 开发过程中，有经验的开发者都会在特定位置有意识的写下断开引用的不可变数据类型。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 引用带来的副作用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a = [&amp;#123; &lt;span class=&quot;attr&quot;&gt;val&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;#125;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; b = a.map(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;item&lt;/span&gt; =&amp;gt;&lt;/span&gt; item.val = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 期望：b 的每一个元素的 val 值变为 2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(a[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].val) &lt;span class=&quot;comment&quot;&gt;// 2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>如何让 (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) 返回 true</title>
    <link href="https://zhangzhao.name/posts/make-a-1-a-2-a-3-evaluate-true/"/>
    <id>https://zhangzhao.name/posts/make-a-1-a-2-a-3-evaluate-true/</id>
    <published>2018-01-17T16:00:00.000Z</published>
    <updated>2019-11-17T03:46:41.583Z</updated>
    
    <content type="html"><![CDATA[<p>前两天在网上看到了一道很有趣的题目，题目大意为：<strong>JS 环境下，如何让 <code>a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3</code> 这个表达式返回 <code>true</code> ？</strong>。</p><p>这道题目乍看之下似乎不太可能，因为在正常情况下，一个变量的值如果没有手动修改，在一个表达式中是不会变化的。当时我也冥思苦想很久，甚至一度怀疑这道题目的答案就是 <strong>不能</strong>。直到在 stackoverflow 上面竟然真的发现了解法 <a href="https://stackoverflow.com/questions/48270127/can-a-1-a-2-a-3-ever-evaluate-to-true" target="_blank" rel="noopener">can-a-1-a-2-a-3-ever-evaluate-to-true</a>。</p><p>让这个表达式成为 <code>true</code> 的关键就在于这里的宽松相等，JS 在处理宽松相等时会对一些变量进行隐式转换。在这种隐式转换的作用下，真的可以让一个变量在一个表达式中变成不同的值。</p><a id="more"></a><h2 id="宽松相等下的真值表"><a href="#宽松相等下的真值表" class="headerlink" title="宽松相等下的真值表"></a>宽松相等下的真值表</h2><p>最高票答案给出的解法为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  i: <span class="number">1</span>,</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello World!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这个答案，我才恍然大悟，这道题目的考点原来是 JS 获取一个变量所需要做的操作以及其中一些细节。在 JS 中有 <code>===</code> 和 <code>==</code> 两种方式来判断两个变量是否相等。对 JS 稍有了解的人都知道，=== 是严格相等，不仅需要两个变量的值相同，还需要类型也相同，而 == 则是宽松下的相等，只需要值相同就能够判断相等，宽松相等是严格相等的子集。所以在 JS 中，严格相等的两个变量一定也是宽松相等的，但是宽松相等的两个变量，大多数情况下并不是严格相等的。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> === <span class="literal">undefined</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> == <span class="string">'1'</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">1</span> === <span class="string">'1'</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>这也就出现了 JS 特有的，变量宽松相等判断的真值表，里面列举了所有在宽松相等比较的情况下，两种变量可能出现的类型：</p><p><img src="/images/truth-table.png" alt="/images/truth-table.png"></p><p>在上面的表格中，ToNumber(A) 尝试在比较前将参数 A 转换为数字，这与 +A（单目运算符+）的效果相同。ToPrimitive(A) 通过尝试依次调用 A 的 A.toString() 和 A.valueOf() 方法，将参数 A 转换为原始值（Primitive）。</p><p>从上图中我们可以看到，当操作数 B 类型为 Number 时，如果希望在宽松相等的情况下整个表达式的结果返回 true，操作数 A 必须满足下面三个条件之一：</p><ol><li>操作数 A 类型为 String，并且调用 +A 的结果与 B 严格相等</li><li>操作数 A 类型为 Boolean，并且调用 +A 的结果与 B 严格相等</li><li>操作数 A 类型为 Object，并且调用 toString 或者 ValueOf 返回的结果与 B 严格相等</li></ol><p>在这里，如果我们要改变 +A 操作的结果相对来说比较困难，因为我们很难在 JS 中去重载 + 操作符的运算。但是在第三种情况下，使 A 的类型为 Object，调用 toString 或 ValueOf 结果与 B 严格相等让我们自己实现就容易的多。</p><p>所以上面的答案就是新建了一个对象 <code>a</code> ，并有 <code>toString</code> 方法，当 JS 引擎每次读取 <code>a</code> 的值的时候，发现需要进行宽松判断一个对象和一个数字之间的结果，对于对象就会执行这里的 <code>toString</code> 方法，在这个方法内部，我们每次增加另一个变量的值并返回，就能够在这条表达式中使得 <code>a</code> 的结果有不同的值。</p><p>同理，换一种写法，<code>a</code> 为 <code>Object</code> ，使用 <code>valueOf</code> 也是可以完成目标的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cosnt a = &#123;</span><br><span class="line">  i: <span class="number">1</span>,</span><br><span class="line">  valueOf() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.i++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello World!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="宽松相等下的-Proxy-对象"><a href="#宽松相等下的-Proxy-对象" class="headerlink" title="宽松相等下的 Proxy 对象"></a>宽松相等下的 Proxy 对象</h2><p>有了上面的思路，下面实现起来就容易的多。在 ES6 中 JS 新增了 <code>Proxy</code> 对象，能够对一个对象进行劫持，接受两个参数，第一个是需要被劫持的对象，第二个参数也是一个对象，内部也可以配置每一个元素的 get 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123; <span class="attr">i</span>: <span class="number">1</span> &#125;, &#123;</span><br><span class="line">  get(target) &#123; <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> target.i++ &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello World!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，Proxy 对象默认的 <code>toString</code> 和 <code>valueOf</code> 方法会返回这个被 getter 劫持过的结果，也能够在宽松相等的条件下满足题意。</p><h2 id="严格相等下的实现"><a href="#严格相等下的实现" class="headerlink" title="严格相等下的实现"></a>严格相等下的实现</h2><p>上面的这几种做法，都是利用了宽松相等条件下，JS 里的一些特殊表现来实现的，放在 === 这种严格相等的条件下就不能够满足，因为严格相等的条件下不会对两个操作数做任何处理，直接比较它们值的大小，这样上面的做法就不能成功。</p><p>但是这种做法给我们提供了很好的思路，在处理类似的问题的时候，就可以从 JS 获取一个变量执行过程中出发，来进行思考。那么接下来，如果题目中的宽松相等换成了严格相等，这样的例子还存在么？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a === <span class="number">1</span> &amp;&amp; a === <span class="number">2</span> &amp;&amp; a === <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello World!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是显然的，这一次当然不能用 hack 对象或者 Proxy 的 <code>toString</code> 或者 <code>ValueOf</code> 方法来做。从 JS 获取变量的过程入手，理所当然的立马能想到的就是数据的 getter 和 setter 方法，通过这样的 hack ，肯定也能达到题目的严格相等的要求。</p><p>在 ES5 之后，<code>Object</code> 新增 <code>defineProperty</code> 方法，它会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回这个对象，对于定义的这个对象有两种描述它的状态，一种称之为数据描述符，一种被称为存取描述符，分别举一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(a, <span class="string">'value'</span>, &#123;</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">  configurable: <span class="literal">false</span>,</span><br><span class="line">  writable: <span class="literal">false</span>,</span><br><span class="line">  value: <span class="string">"static"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这四个数据描述服分别作用是 enumerable 判断是否可以枚举，configurable 判断当前属性是否之后再被更改描述符，writable 判断是否可以继续赋值，value 判断这个结果的值。</p><p>经过这样的操作之后，a 对象下就有了 value 这个 key ，他被赋予不可继续赋值，不可继续配置，不能被枚举，值为 ‘static’，我们可以通过 a.value 拿到这里的 ‘static’，但是不能继续通过 <code>a.value = &#39;relative&#39;</code> 来继续赋值。</p><p>同样的，设置存取描述符也是四个属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">i</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(a, <span class="string">'value'</span>, &#123;</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">  configurable: <span class="literal">false</span>,</span><br><span class="line">  get() &#123; <span class="keyword">return</span> a.i &#125;</span><br><span class="line">  set() &#123; a.i++ &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里设置时就没有配置 writable 和 value 属性，转而配置了 get 和 set 方法，在这两种配置中，get set 方法和 writable value 是不能共存的，否则就会抛出异常。类似上面这样的设置，当我们访问 a.value 时就会调用 get 方法，当我们通过 <code>a.value = &#39;test&#39;</code> 时，就会执行 set 方法。</p><p>所以回归到题目中，当我们访问一个被设置了存取描述符的元素时，如果在 get 方法里面做一些操作，就能巧妙的使得最终的结果达到预期：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">window</span>, <span class="string">'a'</span>, &#123;</span><br><span class="line">  get() &#123; <span class="keyword">return</span> i++ &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a === <span class="number">1</span> &amp;&amp; a === <span class="number">2</span> &amp;&amp; a === <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello World!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，这种劫持 getter 和 setter 的方法本质上是执行了一个函数，内部除了用自增变量，还可以有更多的方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> value = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) <span class="keyword">yield</span> i++</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">window</span>, <span class="string">'a'</span>, &#123;</span><br><span class="line">  get() &#123;</span><br><span class="line">    <span class="keyword">return</span> value.next().value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a === <span class="number">1</span> &amp;&amp; a === <span class="number">2</span> &amp;&amp; a === <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello World!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于严格相等的情况，一般来说只能通过劫持数据的 getter 来进行操作，但是里面具体操作的方法在上面列举的就有很多。</p><p>对于宽松相等的情况，除了劫持 getter 以外，因为宽松相等 JS 引擎的缘故，还能用 Object ， Proxy 对象的 valueOf 和 toString 方法达到目的。</p><p>当然，在 stackoverflow 中有人提出了另一种做法，在 a 变量的前后用不同的字符达到目的，原理就在于某些字符在肉眼条件下是不可见的，所以虽然看起来都是 a ，但变量实际上的不同的，也能达到题目的要求，不过这就不在本文的讨论范围之内了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两天在网上看到了一道很有趣的题目，题目大意为：&lt;strong&gt;JS 环境下，如何让 &lt;code&gt;a == 1 &amp;amp;&amp;amp; a == 2 &amp;amp;&amp;amp; a == 3&lt;/code&gt; 这个表达式返回 &lt;code&gt;true&lt;/code&gt; ？&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这道题目乍看之下似乎不太可能，因为在正常情况下，一个变量的值如果没有手动修改，在一个表达式中是不会变化的。当时我也冥思苦想很久，甚至一度怀疑这道题目的答案就是 &lt;strong&gt;不能&lt;/strong&gt;。直到在 stackoverflow 上面竟然真的发现了解法 &lt;a href=&quot;https://stackoverflow.com/questions/48270127/can-a-1-a-2-a-3-ever-evaluate-to-true&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;can-a-1-a-2-a-3-ever-evaluate-to-true&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;让这个表达式成为 &lt;code&gt;true&lt;/code&gt; 的关键就在于这里的宽松相等，JS 在处理宽松相等时会对一些变量进行隐式转换。在这种隐式转换的作用下，真的可以让一个变量在一个表达式中变成不同的值。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
